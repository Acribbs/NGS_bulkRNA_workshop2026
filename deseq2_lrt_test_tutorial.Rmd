---
title: "DESeq2 Differential Expression Analysis: LRT Test Tutorial"
subtitle: "Factorial Design Analysis of Mouse Mammary Gland Development"
author: "NGS Workshop 2026"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    theme: cosmo
    highlight: tango
---

```{r setup, include=FALSE}
# Troubleshooting: If you encounter pandoc errors, try:
# 1. Restart R session: Session -> Restart R (in RStudio)
# 2. Reinstall rmarkdown: install.packages("rmarkdown")
# 3. Check pandoc: rmarkdown::pandoc_version()
# 4. If issues persist, restart RStudio completely

knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 6,
  echo = TRUE,
  eval = TRUE,
  cache = FALSE
)
```

# Introduction

## Dataset Overview

This tutorial demonstrates differential expression analysis using DESeq2's **Likelihood Ratio Test (LRT)** on a dataset of mouse mammary gland development. The dataset examines gene expression changes in basal and luminal epithelial cells across three developmental stages: virgin, pregnant, and lactating.

**Biological Question:** Which genes show temporal changes in expression during mammary gland development, and do these changes differ between cell types?

## When to Use LRT Tests

The **Likelihood Ratio Test (LRT)** is appropriate for:

- **Testing for ANY change** across multiple conditions or timepoints
- Comparing nested models (full model vs. reduced model)
- Identifying genes with complex expression patterns
- When you want to find all genes that change, regardless of direction
- Testing interaction effects (e.g., different temporal patterns in different cell types)

## Wald Test vs. LRT

| Feature | Wald Test | LRT |
|---------|-----------|-----|
| **Use case** | Pairwise comparisons | Multiple conditions/timepoints |
| **Output** | Log2 fold changes, p-values | Test statistic, p-values (no LFC) |
| **Model comparison** | Single coefficient | Full vs. reduced model |
| **Follow-up** | Direct interpretation | Often followed by pairwise Wald tests |

**Note:** LRT tests whether a gene changes at all, but doesn't tell you which specific comparisons are significant. You often need follow-up Wald tests for specific contrasts.

## Experimental Design

This experiment uses a **factorial design** with 2 cell types × 3 developmental stages × 2 replicates = 12 samples total.

```{r design-table, echo=FALSE}
design_table <- data.frame(
  CellType = rep(rep(c("basal", "luminal"), each = 3), 2),
  Status = rep(c("virgin", "pregnant", "lactate"), 4),
  Group = paste(rep(rep(c("basal", "luminal"), each = 3), 2), 
                rep(c("virgin", "pregnant", "lactate"), 4), sep = "_"),
  Replicate = rep(1:2, each = 6)
)
# Use tryCatch to handle potential pandoc/knitr errors
tryCatch({
  knitr::kable(design_table, caption = "Experimental Design: 2 cell types × 3 stages × 2 replicates = 12 samples")
}, error = function(e) {
  # Fallback: print as a simple table
  cat("Experimental Design: 2 cell types × 3 stages × 2 replicates = 12 samples\n\n")
  print(design_table)
})
```

**Key Design Features:**
- **Cell types:** basal (reference), luminal
- **Developmental stages:** virgin (reference), pregnant, lactate
- **Design formula:** `~ CellType + Status + CellType:Status` (includes interaction term)
- **Interaction term:** Tests whether temporal patterns differ between cell types

---

# Load Libraries and Data

## Required Packages

```{r load-libraries}
library(DESeq2)
library(ggplot2)
library(pheatmap)
library(DEGreport)
library(dplyr)
library(tidyr)
library(tibble)
library(ComplexHeatmap)
library(circlize)
```

## Load Data Files

```{r load-data}
# Load metadata
# Using read.delim for tab-separated files (more reliable than read.table with sep="\t")
metadata <- read.delim("GSE60450_metadata_clean.txt",
                       header = TRUE,
                       stringsAsFactors = FALSE)

# Load counts
counts <- read.delim("GSE60450_counts_ensembl.txt",
                     header = TRUE,
                     stringsAsFactors = FALSE)

# Load gene annotations
gene_annot <- read.delim("GSE60450_gene_annotation.txt",
                         header = TRUE,
                         stringsAsFactors = FALSE)

# Check dimensions
cat("Metadata dimensions:", dim(metadata), "\n")
cat("Counts dimensions:", dim(counts), "\n")
cat("Gene annotation dimensions:", dim(gene_annot), "\n")
```

## Prepare Count Matrix

```{r prepare-counts}
# Check input data
cat("Counts file columns:", paste(colnames(counts), collapse = ", "), "\n")
cat("Number of columns in counts:", ncol(counts), "\n")

# Extract sample columns (everything except EnsemblID and GeneSymbol)
sample_cols <- setdiff(colnames(counts), c("EnsemblID", "GeneSymbol"))
cat("Sample columns found:", length(sample_cols), "\n")
cat("Sample column names:", paste(sample_cols, collapse = ", "), "\n")

if (length(sample_cols) == 0) {
  stop("No sample columns found in counts file. Please check the file format.")
}

# Create count matrix and preserve column names
count_matrix <- as.matrix(counts[, sample_cols, drop = FALSE])

# Ensure column names are preserved
if (is.null(colnames(count_matrix))) {
  cat("Warning: Column names were lost. Restoring from sample_cols.\n")
  colnames(count_matrix) <- sample_cols
}

# Set row names to EnsemblID
if (!is.null(counts$EnsemblID)) {
  rownames(count_matrix) <- counts$EnsemblID
} else {
  stop("EnsemblID column not found in counts file.")
}

# Clean sample names if needed (remove .bam or .sam extensions)
colnames(count_matrix) <- gsub("\\.(bam|sam)$", "", colnames(count_matrix))

# Verify count matrix
cat("Count matrix dimensions:", dim(count_matrix), "\n")
cat("Count matrix has column names:", !is.null(colnames(count_matrix)), "\n")
cat("Sample names in counts:", paste(colnames(count_matrix), collapse = ", "), "\n")
cat("Sample names in metadata:", paste(metadata$Sample, collapse = ", "), "\n")

# Try to match sample names - they might have different formats
# First, try exact match
samples_in_both <- intersect(colnames(count_matrix), metadata$Sample)
cat("Exact matches found:", length(samples_in_both), "\n")

# If no exact matches, try to find partial matches or clean names
if (length(samples_in_both) == 0) {
  cat("\nNo exact matches found. Attempting to match sample names...\n")
  
  # Try removing common prefixes/suffixes and matching
  count_names_clean <- colnames(count_matrix)
  metadata_names_clean <- metadata$Sample
  
  # Try various cleaning strategies
  # Remove file extensions
  count_names_clean <- gsub("\\.(txt|tsv|csv|gz)$", "", count_names_clean)
  metadata_names_clean <- gsub("\\.(txt|tsv|csv|gz)$", "", metadata_names_clean)
  
  # Remove common prefixes
  count_names_clean <- gsub("^X", "", count_names_clean)
  metadata_names_clean <- gsub("^X", "", metadata_names_clean)
  
  # Try matching cleaned names
  samples_in_both <- intersect(count_names_clean, metadata_names_clean)
  if (length(samples_in_both) > 0) {
    cat("Found", length(samples_in_both), "matches after cleaning names\n")
    # Update column names to match
    colnames(count_matrix) <- count_names_clean
    metadata$Sample <- metadata_names_clean
  } else {
    # Try matching by position if same number of samples
    if (ncol(count_matrix) == nrow(metadata)) {
      cat("Same number of samples found. Attempting to match by position...\n")
      cat("This assumes samples are in the same order in both files.\n")
      # We'll match by position in prepare-metadata chunk
    } else {
      cat("\nERROR: Cannot match samples automatically.\n")
      cat("Count matrix samples:", paste(colnames(count_matrix), collapse = ", "), "\n")
      cat("Metadata samples:", paste(metadata$Sample, collapse = ", "), "\n")
      cat("\nPlease check that sample names match between files.\n")
      cat("You may need to manually rename samples in one of the files.\n")
    }
  }
} else {
  cat("Found", length(samples_in_both), "exact matches\n")
}

if (length(samples_in_both) < length(metadata$Sample)) {
  cat("Warning: Some metadata samples not found in counts\n")
  cat("Missing from counts:", paste(setdiff(metadata$Sample, colnames(count_matrix)), collapse = ", "), "\n")
}

if (length(samples_in_both) < length(colnames(count_matrix))) {
  cat("Warning: Some count samples not found in metadata\n")
  cat("Missing from metadata:", paste(setdiff(colnames(count_matrix), metadata$Sample), collapse = ", "), "\n")
}
```

## Prepare Metadata

```{r prepare-metadata}
# Set factors with appropriate reference levels
metadata$Status <- factor(metadata$Status, levels = c("virgin", "pregnant", "lactate"))
metadata$CellType <- factor(metadata$CellType, levels = c("basal", "luminal"))
metadata$Group <- factor(metadata$Group)

# Keep only samples that are in both count matrix and metadata
# Check if count matrix has column names
if (is.null(colnames(count_matrix))) {
  stop("Count matrix has no column names. Please check the prepare-counts chunk.")
}

# Try exact match first
common_samples <- intersect(colnames(count_matrix), metadata$Sample)

cat("Common samples found (exact match):", length(common_samples), "\n")

# If no exact matches, try matching by position (if same number)
if (length(common_samples) == 0 && ncol(count_matrix) == nrow(metadata)) {
  cat("No exact matches, but same number of samples. Matching by position...\n")
  cat("WARNING: This assumes samples are in the same order in both files.\n")
  common_samples <- colnames(count_matrix)
  # Update metadata Sample column to match count matrix column names
  metadata$Sample <- colnames(count_matrix)
  cat("Matched", length(common_samples), "samples by position\n")
}

if (length(common_samples) == 0) {
  cat("\nERROR: Cannot match samples.\n")
  cat("Count matrix column names:", paste(colnames(count_matrix), collapse = ", "), "\n")
  cat("Metadata Sample column:", paste(metadata$Sample, collapse = ", "), "\n")
  cat("\nPossible solutions:\n")
  cat("1. Check that sample names match exactly between files\n")
  cat("2. Rename samples in one file to match the other\n")
  cat("3. If samples are in the same order, the code will match by position\n")
  stop("No common samples found between count matrix and metadata. Please check sample names.")
}

# Filter count matrix to only common samples (preserve column names)
count_matrix <- count_matrix[, common_samples, drop = FALSE]

# Verify column names are preserved
if (is.null(colnames(count_matrix))) {
  cat("Warning: Column names lost during filtering. Restoring.\n")
  colnames(count_matrix) <- common_samples
}
cat("Count matrix column names after filtering:", paste(colnames(count_matrix), collapse = ", "), "\n")

# Filter and reorder metadata to match count matrix column order
# Remove any NAs from match
metadata_match_idx <- match(common_samples, metadata$Sample)
if (any(is.na(metadata_match_idx))) {
  stop("Some common samples not found in metadata. Please check data files.")
}
metadata <- metadata[metadata_match_idx, , drop = FALSE]
rownames(metadata) <- metadata$Sample

# Verify alignment
cat("Count matrix dimensions:", dim(count_matrix), "\n")
cat("Metadata dimensions:", dim(metadata), "\n")
cat("Sample names match:", identical(colnames(count_matrix), rownames(metadata)), "\n")

# Verify
head(metadata)
table(metadata$CellType, metadata$Status)
```

---

# Quality Control

## Total Counts Per Sample

```{r qc-total-counts}
# Diagnostic checks
cat("Count matrix dimensions:", dim(count_matrix), "\n")
cat("Count matrix column names:", paste(colnames(count_matrix), collapse = ", "), "\n")
cat("Metadata dimensions:", dim(metadata), "\n")
cat("Metadata row names:", paste(rownames(metadata), collapse = ", "), "\n")

# Check if data is available
if (ncol(count_matrix) == 0) {
  stop("Count matrix has no columns. Please check data loading.")
}

if (nrow(metadata) == 0) {
  stop("Metadata is empty. Please check data loading.")
}

# Calculate total counts
total_counts <- colSums(count_matrix)
cat("Total counts calculated for", length(total_counts), "samples\n")

# Ensure metadata is aligned with count matrix
if (!identical(colnames(count_matrix), rownames(metadata))) {
  cat("Warning: Aligning metadata with count matrix\n")
  metadata <- metadata[match(colnames(count_matrix), rownames(metadata)), ]
}

# Create QC data frame
qc_df <- data.frame(
  Sample = colnames(count_matrix),
  TotalCounts = as.numeric(total_counts),
  Group = as.character(metadata$Group),
  CellType = as.character(metadata$CellType),
  Status = as.character(metadata$Status),
  stringsAsFactors = FALSE
)

# Verify the data frame
cat("QC data frame dimensions:", dim(qc_df), "\n")
cat("QC data frame columns:", paste(colnames(qc_df), collapse = ", "), "\n")
head(qc_df)

# Create plot
if (nrow(qc_df) > 0) {
  ggplot(qc_df, aes(x = Sample, y = TotalCounts, fill = Group)) +
    geom_bar(stat = "identity") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Total Counts Per Sample",
         y = "Total Read Counts",
         x = "Sample") +
    scale_fill_brewer(palette = "Set3")
} else {
  cat("Error: qc_df is empty. Cannot create plot.\n")
}
```

## Number of Genes Detected Per Sample

```{r qc-genes-detected}
genes_detected <- colSums(count_matrix > 0)
qc_df$GenesDetected <- as.numeric(genes_detected)

ggplot(qc_df, aes(x = Sample, y = GenesDetected, fill = Group)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Number of Genes Detected Per Sample",
       y = "Number of Genes (count > 0)",
       x = "Sample") +
  scale_fill_brewer(palette = "Set3")
```

## PCA Plot of Raw Counts

```{r qc-pca-raw}
# Quick PCA on raw counts to check for batch effects
# Use log-transformed counts for PCA
log_counts <- log2(count_matrix + 1)

# Filter out genes with zero variance (needed for scaling)
gene_vars <- apply(log_counts, 1, var)
keep_genes_pca <- gene_vars > 0
log_counts_filtered <- log_counts[keep_genes_pca, ]

cat("Genes with zero variance removed:", sum(!keep_genes_pca), "\n")
cat("Genes used for PCA:", sum(keep_genes_pca), "\n")

pca_raw <- prcomp(t(log_counts_filtered), scale. = TRUE)

pca_df_raw <- data.frame(
  PC1 = pca_raw$x[, 1],
  PC2 = pca_raw$x[, 2],
  CellType = metadata$CellType,
  Status = metadata$Status,
  Group = metadata$Group
)

percentVar_raw <- round(100 * summary(pca_raw)$importance[2, 1:2])

ggplot(pca_df_raw, aes(x = PC1, y = PC2, color = Status, shape = CellType)) +
  geom_point(size = 4) +
  theme_bw() +
  labs(title = "PCA Plot: Raw Counts (Quality Control)",
       x = paste0("PC1: ", percentVar_raw[1], "% variance"),
       y = paste0("PC2: ", percentVar_raw[2], "% variance")) +
  scale_color_manual(values = c("virgin" = "steelblue", 
                                 "pregnant" = "orange", 
                                 "lactate" = "firebrick")) +
  coord_fixed()
```

**Interpretation:** Samples should cluster by developmental stage and/or cell type. This helps identify any batch effects or unexpected sample relationships.

---

# Create DESeqDataSet Object

## Design Formula with Interaction

For this factorial design, we use:

```
~ CellType + Status + CellType:Status
```

**Term Explanations:**
- **CellType:** Main effect of cell type (basal vs. luminal)
- **Status:** Main effect of developmental stage (virgin, pregnant, lactate)
- **CellType:Status:** **Interaction term** - tests whether the effect of Status differs between CellTypes

**Note:** The interaction term allows us to identify genes where temporal patterns differ between basal and luminal cells. For example, a gene might increase during pregnancy in luminal cells but decrease in basal cells.

## Create DESeqDataSet

```{r create-dds}
# Final verification before creating DESeqDataSet
# Ensure metadata is a data.frame with rownames matching count matrix columns
metadata_df <- as.data.frame(metadata)
rownames(metadata_df) <- colnames(count_matrix)

# Verify alignment one more time
cat("Count matrix column names:", paste(colnames(count_matrix), collapse = ", "), "\n")
cat("Metadata row names:", paste(rownames(metadata_df), collapse = ", "), "\n")
cat("Names match:", identical(colnames(count_matrix), rownames(metadata_df)), "\n")

# Ensure count matrix is numeric
count_matrix <- matrix(as.numeric(count_matrix), 
                       nrow = nrow(count_matrix),
                       ncol = ncol(count_matrix),
                       dimnames = dimnames(count_matrix))

# Create DESeqDataSet with full model including interaction
dds <- DESeqDataSetFromMatrix(
  countData = count_matrix,
  colData = metadata_df,
  design = ~ CellType + Status + CellType:Status
)

# Pre-filter low count genes
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep, ]

cat("Number of genes before filtering:", nrow(count_matrix), "\n")
cat("Number of genes after filtering:", nrow(dds), "\n")
```

---

# Run LRT Test

## LRT: Testing for Interaction Effects

We'll first test for genes with significant **interaction effects** - genes where the temporal pattern differs between cell types.

**Full model:** `~ CellType + Status + CellType:Status`  
**Reduced model:** `~ CellType + Status` (removes interaction)

This tests: "Are there genes where the effect of developmental stage differs between cell types?"

```{r lrt-interaction}
# Run LRT for interaction
dds_lrt_interaction <- DESeq(dds, test = "LRT", reduced = ~ CellType + Status)

# Extract results
res_interaction <- results(dds_lrt_interaction)

# Summary
summary(res_interaction, alpha = 0.05)
```

**Interpretation:** This identifies genes where the temporal response to development differs between basal and luminal cells.

## Alternative LRT: Main Effect of Status

Now we'll test for the **main effect of Status** - genes that change across developmental stages in either or both cell types.

**Full model:** `~ CellType + Status`  
**Reduced model:** `~ CellType` (removes Status)

This tests: "Are there genes that change across developmental stages (regardless of cell type)?"

```{r lrt-status}
# Create new DDS for main effect test
# Use the same properly formatted metadata
metadata_df_status <- as.data.frame(metadata)
rownames(metadata_df_status) <- colnames(count_matrix)

dds_status <- DESeqDataSetFromMatrix(
  countData = count_matrix,
  colData = metadata_df_status,
  design = ~ CellType + Status
)

# Pre-filter
keep <- rowSums(counts(dds_status)) >= 10
dds_status <- dds_status[keep, ]

# Run LRT for main effect of Status
dds_lrt_status <- DESeq(dds_status, test = "LRT", reduced = ~ CellType)

# Extract results
res_status <- results(dds_lrt_status)

# Summary
summary(res_status, alpha = 0.05)
```

## Compare Number of Significant Genes

```{r compare-lrt}
comparison_table <- data.frame(
  Test = c("Interaction Effect", "Main Effect of Status"),
  Significant_Genes = c(
    sum(res_interaction$padj < 0.05, na.rm = TRUE),
    sum(res_status$padj < 0.05, na.rm = TRUE)
  ),
  Total_Tested = c(
    sum(!is.na(res_interaction$padj)),
    sum(!is.na(res_status$padj))
  )
)

comparison_table$Percent_Significant <- round(
  100 * comparison_table$Significant_Genes / comparison_table$Total_Tested, 
  2
)

knitr::kable(comparison_table, 
             caption = "Comparison of LRT Tests",
             digits = 2)
```

**Interpretation:** The main effect test typically identifies more genes because it captures any temporal change, while the interaction test only finds genes with cell-type-specific temporal patterns.

---

# Extract and Explore LRT Results

## Explore Main Status Effect Results

```{r explore-lrt-results}
# Convert to data frame
res_status_df <- as.data.frame(res_status)
res_status_df$EnsemblID <- rownames(res_status_df)

# Add gene annotations
res_status_df <- res_status_df %>%
  left_join(gene_annot[, c("EnsemblID", "GeneSymbol", "GeneName")], 
            by = "EnsemblID")

# Order by p-value
res_status_df <- res_status_df[order(res_status_df$padj, na.last = TRUE), ]

# Show structure
head(res_status_df)
```

**Note:** LRT results don't include log2FoldChange estimates because we're testing multiple coefficients simultaneously. To get fold changes, we need to perform specific contrasts using Wald tests (see section below).

## Top Significant Genes

```{r top-lrt-genes}
# Top 20 most significant genes
top_lrt <- res_status_df %>%
  filter(!is.na(padj)) %>%
  head(20)

knitr::kable(top_lrt[, c("GeneSymbol", "GeneName", "baseMean", "stat", "pvalue", "padj")], 
             digits = 3,
             caption = "Top 20 Most Significant Genes from LRT")
```

---

# Visualizations for LRT Results

## P-value Distributions

```{r lrt-pvalue-histograms}
# Histogram of LRT p-values
p1 <- ggplot(res_status_df, aes(x = pvalue)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black") +
  theme_bw() +
  labs(title = "Distribution of LRT P-values",
       x = "P-value",
       y = "Frequency")

# Histogram of adjusted p-values
p2 <- ggplot(res_status_df, aes(x = padj)) +
  geom_histogram(bins = 50, fill = "coral", color = "black") +
  theme_bw() +
  labs(title = "Distribution of Adjusted P-values (FDR)",
       x = "Adjusted P-value",
       y = "Frequency")

gridExtra::grid.arrange(p1, p2, ncol = 2)
```

## PCA Plot

```{r lrt-pca}
# Transform counts
vsd <- vst(dds_status, blind = FALSE)

# Calculate PCA
pca_data <- plotPCA(vsd, 
                    intgroup = c("Status", "CellType"),
                    returnData = TRUE)

percentVar <- round(100 * attr(pca_data, "percentVar"))

# Plot PCA
ggplot(pca_data, aes(x = PC1, y = PC2, 
                     color = Status, 
                     shape = CellType)) +
  geom_point(size = 4) +
  theme_bw() +
  labs(title = "PCA Plot: Developmental Stage and Cell Type",
       x = paste0("PC1: ", percentVar[1], "% variance"),
       y = paste0("PC2: ", percentVar[2], "% variance")) +
  scale_color_manual(values = c("virgin" = "steelblue", 
                                "pregnant" = "orange", 
                                "lactate" = "firebrick")) +
  coord_fixed()
```

## Heatmap of Top LRT Genes

```{r lrt-heatmap}
# Select top 50 significant genes
top_genes_lrt <- res_status_df %>%
  filter(!is.na(padj), padj < 0.05) %>%
  arrange(padj) %>%
  head(50) %>%
  pull(EnsemblID)

# Extract VST-transformed counts
vsd_subset <- vsd[top_genes_lrt, ]

# Calculate z-scores
mat <- assay(vsd_subset)
mat <- mat - rowMeans(mat)
mat <- mat / apply(mat, 1, sd)

# Add gene symbols
rownames(mat) <- res_status_df$GeneSymbol[match(rownames(mat), res_status_df$EnsemblID)]

# Create annotation
annotation_col <- data.frame(
  Status = colData(vsd_subset)$Status,
  CellType = colData(vsd_subset)$CellType,
  row.names = colnames(mat)
)

# Plot heatmap
pheatmap(mat,
         annotation_col = annotation_col,
         color = colorRampPalette(c("navy", "white", "firebrick"))(100),
         show_rownames = TRUE,
         show_colnames = FALSE,
         cluster_cols = TRUE,
         main = "Top 50 LRT Significant Genes")
```

---

# Temporal Pattern Clustering

## Cluster Genes by Expression Pattern

The `DEGreport::degPatterns()` function clusters genes based on their expression patterns across conditions, which is particularly useful for time-course or multi-condition experiments.

```{r deg-patterns}
# Get significant genes
sig_genes_lrt <- res_status_df %>%
  filter(padj < 0.05, !is.na(padj)) %>%
  pull(EnsemblID)

# Extract VST counts for significant genes
vsd_sig <- vsd[sig_genes_lrt, ]

# Prepare data for degPatterns
# degPatterns expects a MATRIX with genes as rows and samples as columns
# NOT long format - it needs wide format

# Run degPatterns
# Note: This may take a few minutes
# Using a subset if there are too many genes for faster computation
if (length(sig_genes_lrt) > 1000) {
  # Use top 1000 genes for clustering
  top_genes_for_clustering <- res_status_df %>%
    filter(padj < 0.05, !is.na(padj)) %>%
    arrange(padj) %>%
    head(1000) %>%
    pull(EnsemblID)
  
  vsd_sig <- vsd[top_genes_for_clustering, ]
}

# Extract expression matrix (genes as rows, samples as columns)
expression_matrix <- assay(vsd_sig)

# Prepare metadata for degPatterns (one row per sample)
# IMPORTANT: metadata must have samplename as ROW NAMES
metadata_patterns <- colData(vsd_sig) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("samplename") %>%
  select(samplename, Status, CellType, Group) %>%
  distinct(samplename, .keep_all = TRUE) %>%
  as.data.frame()

# Set samplename as row names
rownames(metadata_patterns) <- metadata_patterns$samplename
# Remove samplename column (it's now the row name)
metadata_patterns$samplename <- NULL

# Verify data structure
cat("Expression matrix dimensions:", dim(expression_matrix), "\n")
cat("Expression matrix column names:", paste(colnames(expression_matrix), collapse = ", "), "\n")
cat("Metadata dimensions:", dim(metadata_patterns), "\n")
cat("Metadata row names:", paste(rownames(metadata_patterns), collapse = ", "), "\n")
cat("Column names match row names:", identical(colnames(expression_matrix), rownames(metadata_patterns)), "\n")

# Ensure column names of matrix match row names of metadata
if (!identical(colnames(expression_matrix), rownames(metadata_patterns))) {
  # Reorder metadata to match matrix columns
  metadata_patterns <- metadata_patterns[colnames(expression_matrix), , drop = FALSE]
  cat("Reordered metadata to match matrix columns\n")
}

# Run degPatterns
# Note: degPatterns expects:
# - A matrix with genes as rows and samples as columns
# - metadata: data frame with one row per sample, with samplename as ROW NAMES
patterns <- degPatterns(expression_matrix, 
                        metadata = metadata_patterns,
                        time = "Status",
                        col = "CellType",
                        minc = 5,
                        reduce = TRUE,
                        plot = TRUE)

# Show cluster assignments
head(patterns$df)
```

## Plot Expression Patterns by Cluster

```{r plot-patterns}
# Extract cluster information
cluster_info <- patterns$df

# Create long format data for plotting (from expression matrix)
pattern_data <- expression_matrix %>%
  as.data.frame() %>%
  tibble::rownames_to_column("genes") %>%
  tidyr::pivot_longer(cols = -genes, names_to = "samplename", values_to = "value") %>%
  left_join(
    metadata_patterns %>%
      tibble::rownames_to_column("samplename") %>%
      select(samplename, Status, CellType, Group),
    by = "samplename"
  )

# Merge with cluster information
pattern_data_clustered <- pattern_data %>%
  left_join(cluster_info[, c("genes", "cluster")], by = "genes")

# Calculate mean expression per cluster and group
cluster_means <- pattern_data_clustered %>%
  group_by(cluster, CellType, Status) %>%
  summarize(mean_expression = mean(value), .groups = "drop")

# Plot patterns
ggplot(cluster_means, aes(x = Status, y = mean_expression, 
                          color = CellType, group = CellType)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  facet_wrap(~ cluster, scales = "free_y") +
  theme_bw() +
  labs(title = "Expression Patterns by Cluster",
       y = "Mean VST Expression",
       x = "Developmental Stage") +
  scale_color_manual(values = c("basal" = "steelblue", "luminal" = "coral")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Cluster Summary

```{r cluster-summary}
cluster_summary <- cluster_info %>%
  count(cluster, sort = TRUE) %>%
  mutate(percent = round(100 * n / sum(n), 2))

knitr::kable(cluster_summary, 
             caption = "Number of Genes per Cluster",
             col.names = c("Cluster", "Number of Genes", "Percent"))
```

---

# Pairwise Comparisons (Follow-up Wald Tests)

## Why Follow-up Wald Tests?

LRT tells us which genes change, but not **how** they change. For specific comparisons (e.g., "lactate vs. virgin in luminal cells"), we need Wald tests.

## Extract Specific Contrasts

```{r wald-contrasts}
# First, we need to run DESeq with default Wald test
dds_wald <- DESeq(dds_status)

# Check available coefficients
resultsNames(dds_wald)
```

**Note:** The exact coefficient names depend on the factor levels and reference levels. The output above shows what coefficients are available. We'll use these to construct the appropriate contrasts.

## Lactate vs. Virgin in Luminal Cells

For cell-type-specific contrasts, we need to account for both the main effect and the interaction term.

```{r wald-luminal-lactate-virgin}
# Method 1: Using contrast with interaction terms
# This compares: (luminal, lactate) vs (luminal, virgin)
# We need to check the actual coefficient names first
cat("Available coefficients:\n")
print(resultsNames(dds_wald))

# Lactate vs. Virgin (main effect)
# Note: This shows the main effect of Status, which applies to the reference cell type (basal)
# For cell-type-specific comparisons with interactions, you would need to use the full interaction model
res_luminal_lactate_virgin <- results(dds_wald,
                                       contrast = c("Status", "lactate", "virgin"))

# For cell-type-specific comparison, we can also use:
# Note: This is a simplified approach - for exact cell-type-specific contrasts,
# you may need to use the interaction model or manually construct contrasts
# For now, we show the main effect which applies to the reference cell type (basal)

# Summary
summary(res_luminal_lactate_virgin, alpha = 0.05)

# MA plot
DESeq2::plotMA(res_luminal_lactate_virgin, 
               ylim = c(-3, 3),
               main = "MA Plot: Lactate vs. Virgin (Main Effect)")
```

**Note:** For exact cell-type-specific contrasts with interaction terms, you may need to use the full interaction model (`~ CellType + Status + CellType:Status`) and construct custom contrasts. The examples above show the main effect approach.

## Pregnant vs. Virgin

```{r wald-pregnant-virgin}
# Pregnant vs. Virgin (main effect)
res_pregnant_virgin <- results(dds_wald,
                                contrast = c("Status", "pregnant", "virgin"))

# Summary
summary(res_pregnant_virgin, alpha = 0.05)

# MA plot
DESeq2::plotMA(res_pregnant_virgin,
               ylim = c(-3, 3),
               main = "MA Plot: Pregnant vs. Virgin (Main Effect)")
```

## Lactate vs. Pregnant

```{r wald-lactate-pregnant}
# Lactate vs. Pregnant
res_lactate_pregnant <- results(dds_wald,
                                 contrast = c("Status", "lactate", "pregnant"))

# Summary
summary(res_lactate_pregnant, alpha = 0.05)

# MA plot
DESeq2::plotMA(res_lactate_pregnant,
               ylim = c(-3, 3),
               main = "MA Plot: Lactate vs. Pregnant (Main Effect)")
```

**Note:** For cell-type-specific comparisons with the interaction model, you would use the full model with interaction and construct contrasts that combine the main effect and interaction terms. This tutorial focuses on the LRT approach, with Wald tests shown for the main effects.

---

# Gene-Specific Plots

## Plot Individual Genes Across Timepoints

Let's visualize expression patterns for interesting genes identified by LRT.

```{r gene-plots-temporal}
# Select 4 interesting genes with different patterns
# We'll pick genes from different clusters or with high significance
interesting_genes <- res_status_df %>%
  filter(padj < 0.05, !is.na(padj)) %>%
  arrange(padj) %>%
  head(4)

# Function to plot gene across timepoints
# Use dds_lrt_status which has been processed through DESeq() and has size factors
plot_gene_temporal <- function(ensembl_id, gene_symbol) {
  # Extract normalized counts from the processed DESeqDataSet
  plot_data <- data.frame(
    Count = counts(dds_lrt_status[ensembl_id, ], normalized = TRUE)[1, ],
    Status = colData(dds_lrt_status)$Status,
    CellType = colData(dds_lrt_status)$CellType,
    Sample = colnames(dds_lrt_status)
  )
  
  # Calculate means and SE for each group
  plot_summary <- plot_data %>%
    group_by(CellType, Status) %>%
    summarize(
      mean_count = mean(Count),
      se_count = sd(Count) / sqrt(n()),
      .groups = "drop"
    )
  
  ggplot(plot_summary, aes(x = Status, y = mean_count, 
                           color = CellType, group = CellType)) +
    geom_line(size = 1.2) +
    geom_point(size = 4) +
    geom_errorbar(aes(ymin = mean_count - se_count, 
                      ymax = mean_count + se_count),
                  width = 0.1, size = 0.8) +
    facet_wrap(~ CellType, ncol = 2) +
    scale_y_log10() +
    theme_bw() +
    labs(title = paste0("Expression Pattern: ", gene_symbol),
         y = "Normalized Counts (log10 scale)",
         x = "Developmental Stage") +
    scale_color_manual(values = c("basal" = "steelblue", "luminal" = "coral")) +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 45, hjust = 1))
}

# Plot each gene
for (i in 1:4) {
  print(plot_gene_temporal(interesting_genes$EnsemblID[i], 
                          interesting_genes$GeneSymbol[i]))
}
```

---

# Interaction Effects

## Test for Significant Interactions

We already ran the interaction LRT above. Let's explore those results in more detail.

```{r interaction-results}
# Convert interaction results to data frame
res_interaction_df <- as.data.frame(res_interaction)
res_interaction_df$EnsemblID <- rownames(res_interaction_df)

# Add annotations
res_interaction_df <- res_interaction_df %>%
  left_join(gene_annot[, c("EnsemblID", "GeneSymbol", "GeneName")], 
            by = "EnsemblID") %>%
  arrange(padj)

# Top interaction genes
top_interaction <- res_interaction_df %>%
  filter(padj < 0.05, !is.na(padj)) %>%
  head(10)

knitr::kable(top_interaction[, c("GeneSymbol", "GeneName", "baseMean", "stat", "pvalue", "padj")],
             digits = 3,
             caption = "Top 10 Genes with Significant Interaction Effects")
```

## Plot Genes with Strong Interactions

Genes with significant interactions show different temporal patterns in different cell types.

```{r plot-interactions}
# Select top 4 interaction genes
top4_interaction <- top_interaction %>%
  head(4)

# Plot each
for (i in 1:4) {
  print(plot_gene_temporal(top4_interaction$EnsemblID[i], 
                           top4_interaction$GeneSymbol[i]))
}
```

**Interpretation:** These genes show cell-type-specific responses to developmental stage. For example, a gene might increase during lactation in luminal cells but decrease in basal cells.

---

# Export Results

## Export LRT Significant Genes

```{r export-lrt}
# Filter significant genes from main Status effect
sig_genes_lrt_export <- res_status_df %>%
  filter(padj < 0.05, !is.na(padj)) %>%
  arrange(padj)

# Add cluster information if available
if (exists("cluster_info")) {
  sig_genes_lrt_export <- sig_genes_lrt_export %>%
    left_join(cluster_info[, c("genes", "cluster")], 
              by = c("EnsemblID" = "genes"))
}

# Export columns
export_cols <- c("EnsemblID", "GeneSymbol", "GeneName",
                 "baseMean", "stat", "pvalue", "padj")
if ("cluster" %in% colnames(sig_genes_lrt_export)) {
  export_cols <- c(export_cols, "cluster")
}

write.csv(sig_genes_lrt_export[, export_cols],
          file = "deseq2_lrt_significant_genes.csv",
          row.names = FALSE)

cat("Exported", nrow(sig_genes_lrt_export), 
    "LRT significant genes to deseq2_lrt_significant_genes.csv\n")
```

## Export Interaction Genes

```{r export-interaction}
# Filter significant interaction genes
sig_interaction_export <- res_interaction_df %>%
  filter(padj < 0.05, !is.na(padj)) %>%
  arrange(padj)

write.csv(sig_interaction_export[, c("EnsemblID", "GeneSymbol", "GeneName",
                                     "baseMean", "stat", "pvalue", "padj")],
          file = "deseq2_lrt_interaction_genes.csv",
          row.names = FALSE)

cat("Exported", nrow(sig_interaction_export),
    "interaction genes to deseq2_lrt_interaction_genes.csv\n")
```

## Summary Statistics

```{r summary-stats-lrt}
summary_stats_lrt <- data.frame(
  Metric = c("Total genes tested (Status effect)",
             "Significant genes (Status effect, padj < 0.05)",
             "Total genes tested (Interaction)",
             "Significant interaction genes (padj < 0.05)"),
  Count = c(
    sum(!is.na(res_status_df$padj)),
    sum(res_status_df$padj < 0.05, na.rm = TRUE),
    sum(!is.na(res_interaction_df$padj)),
    sum(res_interaction_df$padj < 0.05, na.rm = TRUE)
  )
)

knitr::kable(summary_stats_lrt, caption = "Summary Statistics")
```

---

# Biological Interpretation

## Overview of Temporal Patterns

The LRT analysis identified `r sum(res_status_df$padj < 0.05, na.rm = TRUE)` genes that change significantly across developmental stages in the mouse mammary gland.

**Key Findings:**

1. **Main Effect of Status:** Many genes show temporal changes during mammary gland development, reflecting the dramatic physiological changes from virgin state through pregnancy to lactation.

2. **Interaction Effects:** `r sum(res_interaction_df$padj < 0.05, na.rm = TRUE)` genes show cell-type-specific temporal patterns, indicating that basal and luminal cells respond differently to developmental cues.

3. **Expression Clusters:** The pattern clustering reveals distinct temporal trajectories:
   - Genes that increase during pregnancy and peak at lactation (lactation-specific genes)
   - Genes that increase during pregnancy but decrease at lactation
   - Genes with complex patterns specific to cell type

## Example: Lactation-Specific Genes

```{r example-lactation}
# Find genes that are highly expressed in lactation
# (This would require examining the actual expression values)
cat("Lactation-specific genes are expected to include:\n")
cat("- Milk protein genes (caseins, whey proteins)\n")
cat("- Lipid synthesis enzymes\n")
cat("- Transport proteins for milk components\n")
cat("- Genes involved in secretory pathways\n")
```

## Basal vs. Luminal Temporal Dynamics

**Basal cells** (myoepithelial cells):
- Provide structural support
- Show changes related to contractile function during lactation
- May have different temporal patterns for structural genes

**Luminal cells** (secretory cells):
- Produce milk components
- Show dramatic upregulation of milk protein genes during lactation
- May have earlier activation of secretory pathways during pregnancy

**Note:** The interaction test specifically identifies genes where these cell types diverge in their temporal responses, which is crucial for understanding cell-type-specific developmental programs.

---

# Session Info

```{r session-info}
sessionInfo()
```

---

# References

Love, M. I., Huber, W., & Anders, S. (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. *Genome Biology*, 15(12), 550. https://doi.org/10.1186/s13059-014-0550-8

DEGreport: Report of DEG analysis. R package version 1.28.0. https://bioconductor.org/packages/DEGreport

---

*End of Tutorial*
